class GraphAlgorithms:



    # Суть заключается в том, что мы проходим граф рекурсивно. Если у вершины есть "дети", то мы вызываем алгоритм от первого из его "детей".
    # Если "детей" нет, то возвращаемся в предыдущую вершину и используем алгоритм для оставшихся "детей". Алгоритм завершается, когда
    # весь граф будет пройден. Граф обязательно должен быть связным, иначе алгоритм пройдет лишь по одной компоненте связности.
    def depth_first_search(array, node=None, answer=None): # Поиск в глубину. На вход подается двумерный массив,
        if answer is None:                                 # где первый индекс - строка таблицы смежности, а
            answer = []                                    # второй - столбец. На выходе получаем массив в
        if node is None:                                   # порядке прохода по вершинам графа с помощью этого алгоритма.
            node = 0
        answer.append(node)
        for next_node in array[node]:
            if next_node not in answer:
                depth_first_search(array, next_node, answer)
        return answer



    # Суть заключается в том, что мы проходим по графу "по уровням". Проходим по вершине, а потом по всем ее "детям". После такого, как "дети"
    # закончились, мы проходимся по "детям" "детей" предыдущей вершины. Алгоритм завершается тогда, когда
    # весь граф будет пройден. Граф обязательно должен быть связным, иначе алгоритм пройдет лишь по одной компоненте связности.
    def breadth_first_search(array, node=None, answer=None):    # Поиск в шиирну. На вход подается двумерный массив,
        answer = []                                             # где первый индекс - строка таблицы смежности, а 
        queue = []                                              # второй - столбец. На выходе получаем массив в
        if node is None:                                        # порядке прохода по вершинам графа с помощью этого алгоритма.
            node = 0
        queue.append(node)
        answer.append(node)
        while queue:
            for next_node in len(array):
                if (array[queue[0]][next_node]) and (next_node not in answer):
                    answer.append(next_node)
                    queue.append(next_node)
            queue.pop(0)
        return answer
        
